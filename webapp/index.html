<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>–ü—Ä–æ—Ñ–¢—Ä–µ–π–¥–õ–∞–± –†–∞–Ω–Ω–µ—Ä</title>
  <!-- –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π favicon, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ 404 -->
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ü¶ñ</text></svg>'>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; }
    body { background: #111; color: #fff; display: grid; place-items: center; }
    .wrap { width: 100%; max-width: 720px; padding: 12px; box-sizing: border-box; }
    .card { background: #1b1b1b; border-radius: 16px; padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { font-size: 18px; margin: 0 0 8px; letter-spacing: .3px; }
    #game { width: 100%; height: auto; background: linear-gradient(#1a1a1a, #151515); border-radius: 12px; display: block; }
    .bar { display:flex; justify-content: space-between; align-items:center; margin: 8px 0 0; gap: 8px; }
    .btn { appearance:none; border:0; border-radius: 10px; padding:10px 14px; background:#2b2b2b; color:#fff; font-weight:600; cursor:pointer; }
    .btn:active { transform: translateY(1px); }
    .muted { opacity:.7; font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>–ü—Ä–æ—Ñ–¢—Ä–µ–π–¥–õ–∞–± –†–∞–Ω–Ω–µ—Ä ü¶ñ</h1>
      <canvas id="game" width="720" height="240"></canvas>
      <div class="bar">
        <div class="muted">–ù–∞–∂–º–∏—Ç–µ: –ü—Ä–æ–±–µ–ª/‚¨ÜÔ∏é –∏–ª–∏ –¢–ê–ü –¥–ª—è –ø—Ä—ã–∂–∫–∞</div>
        <button id="restart" class="btn">–ó–∞–Ω–æ–≤–æ</button>
      </div>
    </div>
  </div>

  <script>
    const tg = window.Telegram?.WebApp;
    try { tg?.expand(); } catch (e) {}
  </script>

  <script>
  (function() {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width; const H = canvas.height;

    const GROUND_Y = H - 32;
    const GRAVITY = 0.7;
    const JUMP_VELOCITY = -12.5;
    const SPEED_START = 6;
    const SPEED_INC = 0.0009;

    let worldSpeed = SPEED_START;
    let score = 0, best = Number(localStorage.getItem('ptl_best') || 0);
    let gameOver = false;

    const player = { x: 50, y: GROUND_Y - 28, w: 32, h: 28, vy: 0, onGround: true };
    const obstacles = [];
    let spawnTimer = 0;

    function reset() {
      worldSpeed = SPEED_START;
      score = 0; gameOver = false;
      player.y = GROUND_Y - player.h; player.vy = 0; player.onGround = true;
      obstacles.length = 0; spawnTimer = 0;
      loop();
    }

    function spawnObstacle() {
      const h = 20 + Math.floor(Math.random()*30);
      const w = 8 + Math.floor(Math.random()*18);
      obstacles.push({ x: W + 10, y: GROUND_Y - h, w, h, passed:false });
    }

    function jump() {
      if (gameOver) return;
      if (player.onGround) { player.vy = JUMP_VELOCITY; player.onGround = false; }
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp' ) { e.preventDefault(); jump(); }
      if (e.code === 'Enter' && gameOver) reset();
    });
    canvas.addEventListener('pointerdown', jump);

    let rafId = null;
    function loop() { cancelAnimationFrame(rafId); rafId = requestAnimationFrame(update); }

    function update() {
      ctx.fillStyle = '#151515'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, GROUND_Y, W, 2);

      spawnTimer -= worldSpeed;
      if (spawnTimer <= 0) { spawnObstacle(); spawnTimer = 120 + Math.random()*140; }

      player.vy += GRAVITY; player.y += player.vy;
      if (player.y >= GROUND_Y - player.h) { player.y = GROUND_Y - player.h; player.vy = 0; player.onGround = true; }

      ctx.fillStyle = '#67e8f9';
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= worldSpeed;
        ctx.fillRect(o.x, o.y, o.w, o.h);
        if (o.x + o.w < 0) obstacles.splice(i,1);
        if (!o.passed && o.x + o.w < player.x) { o.passed = true; score += 1; }
        if (!gameOver && aabb(player, o)) {
          gameOver = true;
          best = Math.max(best, score);
          localStorage.setItem('ptl_best', String(best));
          sendResult();
        }
      }

      ctx.fillStyle = gameOver ? '#ef4444' : '#a3e635';
      roundRect(ctx, player.x, player.y, player.w, player.h, 6); ctx.fill();

      ctx.fillStyle = '#ffffff';
      ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif';
      ctx.textAlign = 'left'; ctx.fillText(`–û—á–∫–∏: ${score}`, 12, 22);
      ctx.textAlign = 'right'; ctx.fillText(`–†–µ–∫–æ—Ä–¥: ${best}`, W - 12, 22);

      if (gameOver) { ctx.textAlign = 'center'; ctx.fillText('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞ ‚Äî Enter/–¢–∞–ø –¥–ª—è —Ä–µ—Å—Ç–∞—Ä—Ç–∞', W/2, H/2); return; }

      worldSpeed += SPEED_INC;
      loop();
    }

    function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function sendResult() {
      try {
        const data = { score, best };
        if (window.Telegram?.WebApp) {
          window.Telegram.WebApp.sendData(JSON.stringify(data));
        }
      } catch(e) {}
    }

    document.getElementById('restart').addEventListener('click', () => { if (!gameOver) return; reset(); });
    canvas.addEventListener('pointerdown', () => { if (gameOver) reset(); });

    update();
  })();
  </script>
</body>
</html>

